import hashlib
import json
import os
import re
import sys
from pathlib import Path

# ... (Version class remains the same)

# Define the version file path relative to this script
VERSION_FILE_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "version.py")
STATE_FILE_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), ".version_state.json")

class Version:
    """
    Semantic Versioning Class
    Handles parsing, stringifying, and incrementing versions according to SemVer.
    Format: Major.Minor.Patch[-PreRelease][+BuildMetadata]
    """
    def __init__(self, major=0, minor=0, patch=0, pre_release=None, build_metadata=None):
        self.major = major
        self.minor = minor
        self.patch = patch
        self.pre_release = pre_release
        self.build_metadata = build_metadata

    def __str__(self):
        v = f"{self.major}.{self.minor}.{self.patch}"
        if self.pre_release:
            v += f"-{self.pre_release}"
        if self.build_metadata:
            v += f"+{self.build_metadata}"
        return v

    def __repr__(self):
        return f"Version({self.major}, {self.minor}, {self.patch}, '{self.pre_release}', '{self.build_metadata}')"

    def __eq__(self, other):
        if not isinstance(other, Version):
            return NotImplemented
        return (self.major, self.minor, self.patch, self.pre_release) == (other.major, other.minor, other.patch, other.pre_release)

    def __lt__(self, other):
        if not isinstance(other, Version):
            return NotImplemented
        # Compare major, minor, patch first
        if (self.major, self.minor, self.patch) != (other.major, other.minor, other.patch):
            return (self.major, self.minor, self.patch) < (other.major, other.minor, other.patch)
        
        # Pre-release logic: 
        # 1.0.0-alpha < 1.0.0
        if self.pre_release is None and other.pre_release is None:
            return False
        if self.pre_release is None: # 1.0.0 > 1.0.0-alpha
            return False
        if other.pre_release is None: # 1.0.0-alpha < 1.0.0
            return True
            
        # Compare pre-release strings lexicographically for simplicity
        # (Strict SemVer requires splitting by dot and comparing numeric parts as numbers)
        return self.pre_release < other.pre_release

    def __le__(self, other):
        return self < other or self == other

    def __gt__(self, other):
        return not (self <= other)

    def __ge__(self, other):
        return not (self < other)

    def bump_major(self):
        """Increments major version. Resets minor and patch."""
        self.major += 1
        self.minor = 0
        self.patch = 0
        self.pre_release = None

    def bump_minor(self):
        """Increments minor version. Resets patch."""
        self.minor += 1
        self.patch = 0
        self.pre_release = None

    def bump_patch(self):
        """Increments patch version."""
        self.patch += 1
        self.pre_release = None

    def set_pre_release(self, pre_release):
        self.pre_release = pre_release

    def set_build_metadata(self, build_metadata):
        self.build_metadata = build_metadata

    @classmethod
    def parse(cls, version_str):
        """Parses a version string into a Version object."""
        pattern = r'^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$'
        match = re.match(pattern, version_str)
        if match:
            major, minor, patch, pre, build = match.groups()
            return cls(int(major), int(minor), int(patch), pre, build)
        parts = version_str.split('.')
        if len(parts) >= 3:
            try:
                return cls(int(parts[0]), int(parts[1]), int(parts[2]))
            except ValueError:
                pass
        return cls(0, 0, 0)

def get_current_version() -> Version:
    """Reads the current version from version.py and returns a Version object."""
    try:
        with open(VERSION_FILE_PATH, "r", encoding="utf-8") as f:
            content = f.read()
            match = re.search(r'VERSION\s*=\s*"([^"]+)"', content)
            if match:
                return Version.parse(match.group(1))
    except FileNotFoundError:
        pass
    return Version(0, 0, 0)

def update_version_file(version_obj: Version):
    """Writes the version object to version.py."""
    with open(VERSION_FILE_PATH, "w", encoding="utf-8") as f:
        f.write(f"# This file is automatically managed by the version manager.\n")
        f.write(f"# Do not edit this file directly unless you know what you are doing.\n")
        f.write(f'VERSION = "{version_obj}"\n')
    print(f"Version updated to {version_obj}")

def calculate_file_hash(filepath: str) -> str:
    """Calculates MD5 hash of a file."""
    hasher = hashlib.md5()
    with open(filepath, 'rb') as f:
        buf = f.read()
        hasher.update(buf)
    return hasher.hexdigest()

def get_project_state(root_dir: str = ".") -> dict:
    """
    Scans the project directory and returns a dictionary of file hashes.
    Ignores version.py, hidden files, and __pycache__.
    """
    state = {}
    root_path = Path(root_dir).resolve()
    
    # Files to ignore
    ignore_files = {"version.py", "utils/version_manager.py", "version_manager.py"}
    
    for path in root_path.rglob("*.py"):
        # Skip if in ignored directories
        if any(part.startswith(".") or part == "__pycache__" or part == "venv" or part == "env" for part in path.parts):
            continue
            
        rel_path = path.relative_to(root_path).as_posix()
        
        # Check explicit ignore list
        if rel_path in ignore_files or path.name in ignore_files:
            continue
            
        state[rel_path] = calculate_file_hash(str(path))
        
    return state

def load_previous_state() -> dict:
    """Loads the previous state from .version_state.json."""
    if os.path.exists(STATE_FILE_PATH):
        try:
            with open(STATE_FILE_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except:
            pass
    return {}

def save_current_state(state: dict):
    """Saves the current state to .version_state.json."""
    with open(STATE_FILE_PATH, "w", encoding="utf-8") as f:
        json.dump(state, f, indent=2)

def auto_bump_if_modified(root_dir: str = "."):
    """
    Checks if any tracked files have changed since the last run.
    If changed, bumps the PATCH version.
    """
    current_state = get_project_state(root_dir)
    previous_state = load_previous_state()
    
    if not previous_state:
        # First run or state file missing - just save current state, don't bump
        save_current_state(current_state)
        return False
        
    changed = False
    
    # Check for modified or new files
    for file, hash_val in current_state.items():
        if file not in previous_state or previous_state[file] != hash_val:
            changed = True
            print(f"[AutoVersion] Detected change in: {file}")
            break
            
    # Check for deleted files (optional, but good for consistency)
    if not changed:
        for file in previous_state:
            if file not in current_state:
                changed = True
                print(f"[AutoVersion] Detected deletion of: {file}")
                break
    
    if changed:
        print("[AutoVersion] Changes detected. Bumping version...")
        bump_version("patch")
        save_current_state(current_state)
        return True
        
    return False

def bump_version(part: str = "patch", pre: str = None, build: str = None):
    """Bumps the version and updates the file."""
    v = get_current_version()
    
    if part == "major":
        v.bump_major()
    elif part == "minor":
        v.bump_minor()
    elif part == "patch":
        v.bump_patch()
        
    if pre is not None:
        v.set_pre_release(pre)
    if build is not None:
        v.set_build_metadata(build)
        
    update_version_file(v)
    return str(v)

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Manage project version (SemVer).")
    parser.add_argument("action", choices=["show", "major", "minor", "patch"], nargs="?", default="show", help="Action to perform")
    parser.add_argument("--pre", help="Set pre-release tag")
    parser.add_argument("--build", help="Set build metadata")
    
    args = parser.parse_args()
    
    if args.action == "show":
        print(f"Current version: {get_current_version()}")
    else:
        bump_version(args.action, args.pre, args.build)
